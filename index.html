<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Transmission Simulator</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 16px; background:#fafafa; }

    .row { display:flex; gap:16px; flex-wrap:wrap; align-items:flex-start; }

    .dashWrap { display:flex; gap:16px; flex-wrap:nowrap; align-items:flex-start; overflow-x:auto; padding-bottom: 2px; }

    .alignLeft { margin-left: 12px; }

    canvas { display:block; }

    /* Shrink gauges + gear/pedal dash to 75% without changing simulation math */
    #gauges { width: 615px; height: 315px; }
    #controlsDash { width: 180px; height: 315px; }

    .card { border:1px solid #ddd; border-radius:12px; padding:12px; background:#fff; }
    label { display:block; margin: 8px 0 2px; font-size: 12px; color:#333; }
    input[type="range"] { width: 260px; }
    input[type="number"] { width: 90px; padding: 3px 5px; font-family: Arial; }
    .grid3 { display:grid; grid-template-columns: 1fr 1fr 1fr; gap:10px 12px; align-items:center; }
    button { padding:8px 12px; border-radius:10px; border:1px solid #aaa; background:#f7f7f7; cursor:pointer; font-family: Arial; }
    button:active { transform: translateY(1px); }
    .small { font-size: 12px; color:#444; font-family: Arial; }
    .btnRow { display:flex; gap:10px; flex-wrap:wrap; margin-top:10px; }

    details { border:none; border-radius:0; padding:0; background:transparent; }
    summary { cursor:pointer; font-weight:700; font-size: 14px; outline:none; }
    summary::-webkit-details-marker { display:none; }
    .settingsInner { margin-top:10px; }
    .hint { margin-top:8px; line-height: 1.35; }
    .settingsGap { margin-top:14px; }

    .plotCard { width: 884px; }
    .plotTitle { text-align:center; }

    .controlsBar { padding: 0; background: transparent; border: none; border-radius: 0; }
    .gridTight { display:grid; grid-template-columns: 1fr 1fr 1fr; gap:4px 10px; align-items:center; }
  </style>
</head>
<body>
  <h2>Transmission Simulator: RPM vs Time, RPM vs Vehicle Speed</h2>

  <div class="row" style="margin-top:12px">
    <div class="alignLeft controlsBar" style="min-width: 320px;">
      <div class="btnRow">
        <button id="start">Start</button>
        <button id="stop">Stop</button>
        <button id="reset">Reset</button>
      </div>
    </div>
  </div>

  <div class="row">
    <div class="dashWrap alignLeft">
      <canvas id="gauges" width="820" height="420"></canvas>
      <canvas id="controlsDash" width="240" height="420"></canvas>
    </div>
  </div>

  <div class="row" style="margin-top:16px">
    <div class="card plotCard alignLeft">
      <div class="small plotTitle"><b>RPM vs time</b></div>
      <canvas id="plotTime" width="860" height="280"></canvas>
    </div>
  </div>

  <div class="row" style="margin-top:16px">
    <div class="card plotCard alignLeft">
      <div class="small plotTitle"><b>RPM vs vehicle speed</b></div>
      <canvas id="plotSpeed" width="860" height="280"></canvas>
    </div>
  </div>

  <div class="row" style="margin-top:16px">
    <div class="card alignLeft" style="width: 884px; max-width: 100%;">
      <details id="settings">
        <summary>Settings</summary>
        <div class="settingsInner">
          <label>Driver throttle input</label>
          <input id="throttleIn" type="range" min="0" max="1" step="0.01" value="0.70"/>
          <div class="small" id="throttleLabel"></div>

          <label>Auto shift</label>
          <input id="auto" type="checkbox" checked/>

          <label>Loop after 2 min inactivity</label>
          <input id="loop" type="checkbox" checked/>

          <label>Inactivity time (seconds)</label>
          <input id="idleSeconds" type="number" min="5" max="3600" step="5" value="120"/>
          <div class="small hint">
            If enabled, the simulator will reset and start again after the selected number of seconds with no keyboard, mouse, touch, or control changes.
          </div>

          <div class="settingsGap"></div>
          <div class="small"><b>What counts as activity</b> (for the loop timer)</div>
          <div class="small" style="margin-top:6px; display:grid; grid-template-columns: 1fr 1fr; gap:6px 12px; max-width: 340px;">
            <label style="display:flex; gap:8px; align-items:center; margin:0;">
              <input id="idle_keyboard" type="checkbox" checked/> <span>Keyboard</span>
            </label>
            <label style="display:flex; gap:8px; align-items:center; margin:0;">
              <input id="idle_pointer" type="checkbox" checked/> <span>Mouse or tap</span>
            </label>
            <label style="display:flex; gap:8px; align-items:center; margin:0;">
              <input id="idle_move" type="checkbox"/> <span>Mouse move</span>
            </label>
            <label style="display:flex; gap:8px; align-items:center; margin:0;">
              <input id="idle_wheel" type="checkbox" checked/> <span>Scroll wheel</span>
            </label>
            <label style="display:flex; gap:8px; align-items:center; margin:0;">
              <input id="idle_touch" type="checkbox" checked/> <span>Touch gestures</span>
            </label>
            <label style="display:flex; gap:8px; align-items:center; margin:0;">
              <input id="idle_controls" type="checkbox" checked/> <span>Control changes</span>
            </label>
          </div>
          <div class="small hint" style="margin-top:8px">
            Tip: leave “Mouse move” off if you don't want small cursor motion to keep the sim running.
          </div>

          <label>Upshift RPM (global fallback)</label>
          <input id="upshift" type="range" min="1500" max="7000" step="50" value="4500"/>
          <div class="small" id="upshiftLabel"></div>

          <div style="margin-top:12px">
            <div class="small"><b>Per-gear upshift RPM</b> (used in auto shift)</div>
            <div class="gridTight small" style="margin-top:6px">
              <div>1</div><input id="u1" type="number" min="1500" max="9000" step="50" value="4500"/><div>rpm</div>
              <div>2</div><input id="u2" type="number" min="1500" max="9000" step="50" value="4500"/><div>rpm</div>
              <div>3</div><input id="u3" type="number" min="1500" max="9000" step="50" value="4500"/><div>rpm</div>
              <div>4</div><input id="u4" type="number" min="1500" max="9000" step="50" value="4500"/><div>rpm</div>
              <div>5</div><input id="u5" type="number" min="1500" max="9000" step="50" value="4500"/><div>rpm</div>
              <div>6</div><input id="u6" type="number" min="1500" max="9000" step="50" value="4500"/><div>rpm</div>
            </div>
            <div class="small hint">
              If a gear value is missing or invalid, the global Upshift RPM slider is used as fallback.
            </div>
          </div>

          <label>Downshift RPM</label>
          <input id="downshift" type="range" min="800" max="4500" step="50" value="1400"/>
          <div class="small" id="downshiftLabel"></div>

          <label>Shift time (s)</label>
          <input id="shiftTime" type="range" min="0.08" max="0.70" step="0.01" value="0.22"/>
          <div class="small" id="shiftTimeLabel"></div>

          <label>Total run time (s)</label>
          <input id="runTime" type="number" min="5" max="600" step="1" value="120"/>

          <label>Simulation speed (x)</label>
          <input id="simRate" type="number" min="0.1" max="50" step="0.1" value="1.0"/>
          <div class="small hint">
            Example: set speed to 5.0 to finish a 120 s run in about 24 s of real time.
          </div>

          <label>Drag force (aero coefficient)</label>
          <input id="dragCoef" type="range" min="0.00" max="1.20" step="0.01" value="0.32"/>
          <div class="small" id="dragCoefLabel"></div>

          <div style="margin-top:12px">
            <div class="small"><b>Gear ratios</b></div>
            <div class="gridTight small">
              <div>1</div><input id="g1" type="number" step="0.01" value="3.60"/><div>:1</div>
              <div>2</div><input id="g2" type="number" step="0.01" value="2.19"/><div>:1</div>
              <div>3</div><input id="g3" type="number" step="0.01" value="1.41"/><div>:1</div>
              <div>4</div><input id="g4" type="number" step="0.01" value="1.00"/><div>:1</div>
              <div>5</div><input id="g5" type="number" step="0.01" value="0.83"/><div>:1</div>
              <div>6</div><input id="g6" type="number" step="0.01" value="0.72"/><div>:1</div>
              <div>FD</div><input id="fd" type="number" step="0.01" value="3.90"/><div>:1</div>
            </div>
          </div>
        </div>
      </details>
    </div>
  </div>

<script>
(() => {
  // ----------------- Config -----------------
  let gears = [0, 3.60, 2.19, 1.41, 1.00, 0.83, 0.72];
  let finalDrive = 3.90;

  const redline = 6500;
  const idleRPM = 750;

  const STARTUP_DELAY_S = 9.0;
  const STARTUP_SPINUP_S = 2.0;

  const tireRadiusM = 0.315;
  const vehicleMassKg = 1700;

  // toy road load
  let dragCoef = 0.32;
  const rollingN = 90;

  const maxWheelForce = 4200;
  const speedMaxMph = 120;

  // ----------------- UI -----------------
  const elThrottleIn = document.getElementById('throttleIn');
  const elAuto = document.getElementById('auto');
  const elLoop = document.getElementById('loop');
  const elUpshift = document.getElementById('upshift');
  const elDownshift = document.getElementById('downshift');
  const elShiftTime = document.getElementById('shiftTime');
  const elRunTime = document.getElementById('runTime');
  const elSimRate = document.getElementById('simRate');
  const elDragCoef = document.getElementById('dragCoef');

  const throttleLabel = document.getElementById('throttleLabel');
  const upshiftLabel = document.getElementById('upshiftLabel');
  const downshiftLabel = document.getElementById('downshiftLabel');
  const shiftTimeLabel = document.getElementById('shiftTimeLabel');
  const dragCoefLabel = document.getElementById('dragCoefLabel');

  const upshiftGearInputs = {
    u1: document.getElementById('u1'),
    u2: document.getElementById('u2'),
    u3: document.getElementById('u3'),
    u4: document.getElementById('u4'),
    u5: document.getElementById('u5'),
    u6: document.getElementById('u6'),
  };

  const gearInputs = {
    g1: document.getElementById('g1'),
    g2: document.getElementById('g2'),
    g3: document.getElementById('g3'),
    g4: document.getElementById('g4'),
    g5: document.getElementById('g5'),
    g6: document.getElementById('g6'),
    fd: document.getElementById('fd')
  };

  // Start / stop / reset
  let running = false;
  document.getElementById('start').onclick = () => { running = true; markInteraction(); };
  document.getElementById('stop').onclick  = () => { running = false; markInteraction(); };
  document.getElementById('reset').onclick = () => { reset(); markInteraction(); };

  // Loop after inactivity (optional)
  const elIdleSeconds = document.getElementById("idleSeconds");

  function getInactivityRestartMs(){
    let s = 120;
    if (elIdleSeconds){
      s = parseFloat(elIdleSeconds.value);
      if (!Number.isFinite(s)) s = 120;
      s = Math.max(5, Math.min(3600, s)); // clamp 5s to 1h
      elIdleSeconds.value = String(Math.round(s));
    }
    return s * 1000;
  }

  const elIdleKeyboard = document.getElementById("idle_keyboard");
  const elIdlePointer  = document.getElementById("idle_pointer");
  const elIdleMove     = document.getElementById("idle_move");
  const elIdleWheel    = document.getElementById("idle_wheel");
  const elIdleTouch    = document.getElementById("idle_touch");
  const elIdleControls = document.getElementById("idle_controls");

  let lastInteractionMs = performance.now();

  function isActivityEnabled(source){
    switch(source){
      case "keyboard": return !!(elIdleKeyboard && elIdleKeyboard.checked);
      case "pointer":  return !!(elIdlePointer  && elIdlePointer.checked);
      case "move":     return !!(elIdleMove     && elIdleMove.checked);
      case "wheel":    return !!(elIdleWheel    && elIdleWheel.checked);
      case "touch":    return !!(elIdleTouch    && elIdleTouch.checked);
      case "controls": return !!(elIdleControls && elIdleControls.checked);
      default: return true;
    }
  }

  function markInteraction(source){
    if (source && !isActivityEnabled(source)) return;
    lastInteractionMs = performance.now();
  }

  document.addEventListener("input", (e) => markInteraction("controls"), { passive: true });

  window.addEventListener("keydown",     () => markInteraction("keyboard"), { passive: true });
  window.addEventListener("pointerdown", () => markInteraction("pointer"),  { passive: true });
  window.addEventListener("pointermove", () => markInteraction("move"),     { passive: true });
  window.addEventListener("wheel",       () => markInteraction("wheel"),    { passive: true });
  window.addEventListener("touchstart",  () => markInteraction("touch"),    { passive: true });
  document.addEventListener("change", markInteraction, { passive: true });

  // ----------------- Helpers -----------------
  function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }
  function mph(ms){ return ms * 2.2369362921; }
  function smoothstep01(x){ x = clamp(x,0,1); return x*x*(3-2*x); }

  function ordinal(n){
    const v = n % 100;
    if (v >= 11 && v <= 13) return `${n}th`;
    switch (n % 10){
      case 1: return `${n}st`;
      case 2: return `${n}nd`;
      case 3: return `${n}rd`;
      default: return `${n}th`;
    }
  }

  function sanitizePositiveNumber(el, fallback){
    let v = parseFloat(el.value);
    if (!Number.isFinite(v) || v <= 0) v = fallback;
    el.value = v.toFixed(2);
    return v;
  }

  function sanitizeRpmNumber(el, fallback){
    let v = parseFloat(el.value);
    if (!Number.isFinite(v) || v <= 0) v = fallback;
    v = Math.round(v / 50) * 50;
    el.value = String(v);
    return v;
  }

  function getUpshiftRpmForGear(currentGear, globalFallback){
    const key = `u${currentGear}`;
    const el = upshiftGearInputs[key];
    if (!el) return globalFallback;
    const v = parseFloat(el.value);
    if (!Number.isFinite(v) || v <= 0) return globalFallback;
    return v;
  }

  function updateRatiosFromUI(){
    const g1 = sanitizePositiveNumber(gearInputs.g1, 3.60);
    const g2 = sanitizePositiveNumber(gearInputs.g2, 2.19);
    const g3 = sanitizePositiveNumber(gearInputs.g3, 1.41);
    const g4 = sanitizePositiveNumber(gearInputs.g4, 1.00);
    const g5 = sanitizePositiveNumber(gearInputs.g5, 0.83);
    const g6 = sanitizePositiveNumber(gearInputs.g6, 0.72);
    const fd = sanitizePositiveNumber(gearInputs.fd, 3.90);

    gears = [0, g1, g2, g3, g4, g5, g6];
    finalDrive = fd;
  }
  Object.values(gearInputs).forEach(el => {
    el.addEventListener('change', updateRatiosFromUI);
    el.addEventListener('blur', updateRatiosFromUI);
  });
  updateRatiosFromUI();

  Object.values(upshiftGearInputs).forEach(el => {
    el.addEventListener('change', () => sanitizeRpmNumber(el, parseFloat(elUpshift.value)));
    el.addEventListener('blur', () => sanitizeRpmNumber(el, parseFloat(elUpshift.value)));
  });

  function ratioForGear(g){
    return gears[g] * finalDrive;
  }

  function speedToRPM(speedMs, ratio){
    const wheelRps = speedMs / (2 * Math.PI * tireRadiusM);
    const wheelRpm = wheelRps * 60;
    return wheelRpm * ratio;
  }

  function wheelForceFromThrottle(throttle, gear, rpm){
    const gearFactor = (gears[gear] / gears[1]);
    const rpmFactor = 0.6 + 0.4 * (1 - Math.abs((rpm - 3200) / 4200));
    return maxWheelForce * throttle * clamp(gearFactor, 0.25, 1.0) * clamp(rpmFactor, 0.4, 1.0);
  }

  // ----------------- State -----------------
  let t = 0;
  let v = 0;
  let rpm = 0;
  let gear = 1;

  let shifting = false;
  let shiftTimer = 0;
  let shiftTotal = 0;

  let clutch = 1;
  let throttleEff = 0;
  let brake = 0;

  const timeSeries = [];
  const speedSeries = [];
  const shiftMarksTime = [];
  const shiftMarksSpeed = [];

  // ----------------- Shift logic -----------------
  const SHIFT_LOCKOUT_S = 0.65;
  const SHIFT_HYSTERESIS_RPM = 150;
  const MIN_UPSHIFT_ABOVE_DOWNSHIFT = 300;
  let lastShiftEndAt = -1;
  function beginShift(nextGear){
    shifting = true;
    shiftTotal = parseFloat(elShiftTime.value);
    shiftTimer = shiftTotal;

    const vMph = mph(v);
    const label = `${ordinal(nextGear)}\ngear`;

    shiftMarksTime.push({ x: t, y: rpm, label });
    shiftMarksSpeed.push({ x: vMph, y: rpm, label });

    gear = nextGear;
  }

  function updatePedals(driverThrottle, dt){
    if (!shifting) {
      clutch += (0 - clutch) * (1 - Math.exp(-dt / 0.08));
      throttleEff += (driverThrottle - throttleEff) * (1 - Math.exp(-dt / 0.12));
      brake += (0 - brake) * (1 - Math.exp(-dt / 0.10));
      return;
    }

    const progress = clamp(1 - shiftTimer / shiftTotal, 0, 1);

    const upEnd = 0.22;
    const downStart = 0.72;

    let clutchTarget = 0;
    if (progress < upEnd) clutchTarget = progress / upEnd;
    else if (progress < downStart) clutchTarget = 1;
    else clutchTarget = 1 - (progress - downStart) / (1 - downStart);

    let throttleTarget = 0.02;
    if (progress > 0.75) {
      const back = (progress - 0.75) / 0.25;
      throttleTarget = 0.02 + back * (driverThrottle - 0.02);
    }

    clutch += (clutchTarget - clutch) * (1 - Math.exp(-dt / 0.05));
    throttleEff += (throttleTarget - throttleEff) * (1 - Math.exp(-dt / 0.05));
    brake += (0 - brake) * (1 - Math.exp(-dt / 0.05));
  }

  // ----------------- Physics update -----------------
  function update(dt){
    const runDurationS = clamp(parseFloat(elRunTime.value) || 120, 5, 600);
    const simRate = clamp(parseFloat(elSimRate.value) || 1, 0.1, 50);

    dt *= simRate;

    if (t >= runDurationS) { running = false; return; }

    updateRatiosFromUI();

    t = Math.min(runDurationS, t + dt);

    const driverThrottle = parseFloat(elThrottleIn.value);
    const upshiftGlobal = parseFloat(elUpshift.value);
    const downshiftRPM = parseFloat(elDownshift.value);

    let upshiftRPM = getUpshiftRpmForGear(gear, upshiftGlobal);
    upshiftRPM = Math.max(upshiftRPM, downshiftRPM + MIN_UPSHIFT_ABOVE_DOWNSHIFT);

    // STARTUP PHASE
    if (t < STARTUP_DELAY_S) {
      const spinP = smoothstep01(t / STARTUP_SPINUP_S);
      rpm = idleRPM * spinP;

      v = 0;
      brake = 0.2;
      throttleEff = 0;
      clutch = 1.0;

      shifting = false;
      shiftTimer = 0;
      lastShiftEndAt = -1;

      const vMph = mph(v);
      timeSeries.push({x:t, y:rpm});
      speedSeries.push({x:vMph, y:rpm});

      throttleLabel.textContent = `Driver throttle: ${(driverThrottle*100).toFixed(0)}% (applies after ${STARTUP_DELAY_S.toFixed(0)} s)`;
      upshiftLabel.textContent = `Upshift: ${upshiftRPM.toFixed(0)} rpm (gear ${gear})`;
      downshiftLabel.textContent = `Downshift: ${downshiftRPM.toFixed(0)} rpm`;
      shiftTimeLabel.textContent = `Shift time: ${parseFloat(elShiftTime.value).toFixed(2)} s`;
      return;
    }

    // DRIVING PHASE
    updatePedals(driverThrottle, dt);

    if (elAuto.checked && !shifting) {
      const sinceShift = (lastShiftEndAt < 0) ? 1e9 : (t - lastShiftEndAt);
      if (sinceShift >= SHIFT_LOCKOUT_S) {
        if (rpm > (upshiftRPM + SHIFT_HYSTERESIS_RPM) && gear < gears.length - 1) beginShift(gear + 1);
        else if (rpm < (downshiftRPM - SHIFT_HYSTERESIS_RPM) && gear > 1) beginShift(gear - 1);
      }
    }

    const clutchEngaged = (clutch < 0.15);
    const clutchFactor = clutchEngaged ? 1.0 : 0.18;

    const coupledRPM = speedToRPM(v, ratioForGear(gear));

    if (shifting) {
      shiftTimer -= dt;
      const target = clamp(coupledRPM, idleRPM, redline);
      rpm += (target - rpm) * (1 - Math.exp(-dt / 0.07));
      if (shiftTimer <= 0) { shifting = false; lastShiftEndAt = t; }
    } else {
      const lead = 120 + 380 * throttleEff;
      const target = clamp(coupledRPM + lead, idleRPM, redline);
      rpm += (target - rpm) * (1 - Math.exp(-dt / 0.12));
    }

    const driveForce = wheelForceFromThrottle(throttleEff, gear, rpm) * clutchFactor;
    const dragForce = dragCoef * v * v + rollingN;
    const brakeForce = 5200 * brake;
    const a = (driveForce - dragForce - brakeForce) / vehicleMassKg;
    v = Math.max(0, v + a * dt);

    if (v < 0.4 && driverThrottle < 0.03 && !shifting) {
      rpm += (idleRPM - rpm) * (1 - Math.exp(-dt / 0.2));
    }

    const vMph = mph(v);
    timeSeries.push({x:t, y:rpm});
    speedSeries.push({x:vMph, y:rpm});

    throttleLabel.textContent = `Driver throttle: ${(driverThrottle*100).toFixed(0)}%`;
    upshiftLabel.textContent = `Upshift: ${upshiftRPM.toFixed(0)} rpm (gear ${gear})`;
    downshiftLabel.textContent = `Downshift: ${downshiftRPM.toFixed(0)} rpm`;
    shiftTimeLabel.textContent = `Shift time: ${parseFloat(elShiftTime.value).toFixed(2)} s`;
  }

  // ----------------- Drawing -----------------
  const gaugesCtx = document.getElementById('gauges').getContext('2d');
  const controlsCtx = document.getElementById('controlsDash').getContext('2d');

  function roundRectPath(ctx, x, y, w, h, r){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
  }

  function drawClusterGauge(ctx, cx, cy, radius, value, vmin, vmax, majorStep, minorStep, opts){
    const {
      title,
      unitLabel,
      faceColor = "#2f2f2f",
      ringColor = "#dcdcdc",
      tickColor = "#f0f0f0",
      textColor = "#f5f5f5",
      needleColor = "#ff4040",
      redStartFrac = 0.80,
      showX1000 = false,
      digitalText = "",
      numberFormatter = (x) => String(x),
      startAngle = Math.PI * 0.75,
      endAngle = Math.PI * 2.25
    } = opts;

    function angFor(u){
      const p = clamp((u - vmin) / (vmax - vmin), 0, 1);
      return startAngle + (endAngle - startAngle) * p;
    }

    ctx.save();

    ctx.fillStyle = faceColor;
    ctx.beginPath();
    ctx.arc(cx, cy, radius + 10, 0, Math.PI*2);
    ctx.fill();

    ctx.lineWidth = 10;
    ctx.strokeStyle = ringColor;
    ctx.beginPath();
    ctx.arc(cx, cy, radius, startAngle, endAngle);
    ctx.stroke();

    const redStart = startAngle + (endAngle - startAngle) * redStartFrac;
    ctx.strokeStyle = "#d32020";
    ctx.beginPath();
    ctx.arc(cx, cy, radius, redStart, endAngle);
    ctx.stroke();

    ctx.lineWidth = 2;
    ctx.strokeStyle = tickColor;
    for (let u = vmin; u <= vmax + 1e-9; u += minorStep) {
      const a = angFor(u);
      const x0 = cx + Math.cos(a) * (radius - 10);
      const y0 = cy + Math.sin(a) * (radius - 10);
      const x1 = cx + Math.cos(a) * (radius + 2);
      const y1 = cy + Math.sin(a) * (radius + 2);
      ctx.beginPath();
      ctx.moveTo(x0,y0);
      ctx.lineTo(x1,y1);
      ctx.stroke();
    }

    ctx.lineWidth = 3;
    ctx.fillStyle = textColor;
    ctx.font = "22px Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    for (let u = vmin; u <= vmax + 1e-9; u += majorStep) {
      const a = angFor(u);
      const x0 = cx + Math.cos(a) * (radius - 18);
      const y0 = cy + Math.sin(a) * (radius - 18);
      const x1 = cx + Math.cos(a) * (radius + 2);
      const y1 = cy + Math.sin(a) * (radius + 2);
      ctx.beginPath();
      ctx.moveTo(x0,y0);
      ctx.lineTo(x1,y1);
      ctx.stroke();

      const tx = cx + Math.cos(a) * (radius - 36);
      const ty = cy + Math.sin(a) * (radius - 36);
      ctx.fillText(numberFormatter(u), tx, ty);
    }

    const aVal = angFor(value);
    ctx.lineWidth = 4;
    ctx.strokeStyle = needleColor;
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.lineTo(cx + Math.cos(aVal) * (radius - 24), cy + Math.sin(aVal) * (radius - 24));
    ctx.stroke();

    ctx.fillStyle = "#111";
    ctx.beginPath();
    ctx.arc(cx, cy, 8, 0, Math.PI*2);
    ctx.fill();

    ctx.fillStyle = textColor;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.font = "16px Arial";
    ctx.fillText(title, cx, cy + radius - 18);
    ctx.font = "14px Arial";
    ctx.fillText(showX1000 ? "x1000 RPM" : unitLabel, cx, cy + radius - 4);

    const boxW = 150, boxH = 34;
    const bx = cx - boxW/2;
    const by = cy + radius + 32;
    ctx.fillStyle = "#101010";
    ctx.strokeStyle = "#666";
    ctx.lineWidth = 1;
    roundRectPath(ctx, bx, by, boxW, boxH, 8);
    ctx.fill();
    ctx.stroke();

    ctx.fillStyle = "#eaeaea";
    ctx.font = "18px Arial";
    ctx.fillText(digitalText, cx, by + boxH/2 + 1);

    ctx.restore();
  }

  function drawGearLadder(ctx, x, y, w, h, currentGear){
    ctx.save();
    ctx.fillStyle = "#0f0f0f";
    roundRectPath(ctx, x, y, w, h, 18);
    ctx.fill();

    ctx.fillStyle = "#f2f2f2";
    ctx.font = "18px Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("GEAR", x + w/2, y + 18);

    const items = ["1","2","3","4","5","6"];
    const top = y + 38;
    const rowH = (h - 50) / items.length;

    for (let i=0;i<items.length;i++){
      const gy = top + i*rowH;
      const isActive = (parseInt(items[i],10) === currentGear);

      if (isActive){
        ctx.fillStyle = "#ffffff";
        roundRectPath(ctx, x + 14, gy + 5, w - 28, rowH - 10, 12);
        ctx.fill();
      }

      ctx.fillStyle = isActive ? "#111" : "rgba(255,255,255,0.55)";
      ctx.font = "18px Arial";
      ctx.fillText(items[i], x + w/2, gy + rowH/2);

      ctx.strokeStyle = "rgba(255,255,255,0.08)";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(x + 12, gy + rowH);
      ctx.lineTo(x + w - 12, gy + rowH);
      ctx.stroke();
    }

    ctx.restore();
  }

  function drawPedal(ctx, x, y, w, h, label, pressed01){
    ctx.save();

    ctx.fillStyle = "rgba(0,0,0,0.12)";
    roundRectPath(ctx, x+3, y+4, w, h, 16);
    ctx.fill();

    const g = ctx.createLinearGradient(x, y, x, y+h);
    g.addColorStop(0, "#3a3a3a");
    g.addColorStop(1, "#2a2a2a");

    ctx.fillStyle = g;
    ctx.strokeStyle = "rgba(255,255,255,0.18)";
    ctx.lineWidth = 2;
    roundRectPath(ctx, x, y, w, h, 16);
    ctx.fill();
    ctx.stroke();

    ctx.strokeStyle = "rgba(255,255,255,0.15)";
    ctx.lineWidth = 2;
    const treadCount = 7;
    for (let i=0;i<treadCount;i++){
      const yy = y + 18 + i * ((h - 36) / (treadCount-1));
      ctx.beginPath();
      ctx.moveTo(x + 10, yy);
      ctx.lineTo(x + w - 10, yy);
      ctx.stroke();
    }

    if (pressed01 > 0.02){
      ctx.save();
      ctx.globalCompositeOperation = "lighter";
      ctx.shadowColor = "rgba(80,255,120,0.65)";
      ctx.shadowBlur = 14;

      const a = 0.12 + 0.36 * pressed01;
      ctx.fillStyle = `rgba(80,255,120,${a})`;
      roundRectPath(ctx, x, y, w, h, 16);
      ctx.fill();

      ctx.restore();
    }

    ctx.fillStyle = "#f2f2f2";
    ctx.font = "14px Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "top";
    ctx.fillText(label, x + w/2, y + h + 6);

    ctx.restore();
  }

  function drawGaugesPanel(){
    const ctx = gaugesCtx;
    ctx.clearRect(0,0,ctx.canvas.width,ctx.canvas.height);

    ctx.fillStyle = "#0f0f0f";
    roundRectPath(ctx, 12, 12, ctx.canvas.width - 24, ctx.canvas.height - 24, 18);
    ctx.fill();

ctx.fillStyle = "#f2f2f2";
ctx.font = "20px Arial";
ctx.textAlign = "center";
ctx.textBaseline = "middle";

// Decide status text
let statusText;
if (!running) {
  statusText = "OFF";
} else if (shifting) {
  statusText = "SHIFTING";
} else if (rpm < (idleRPM - 5)) {
  // Only show STARTUP while RPM is still climbing to idle
  statusText = "STARTUP";
} else if (throttleEff > 0.03) {
  statusText = "UNDER THROTTLE";
} else {
  statusText = "IDLE";
}

// Draw a dynamic-size label box based on text width
const paddingX = 18;
const boxH = 28;
const textW = ctx.measureText(statusText).width;
const boxW = Math.max(120, Math.min(320, textW + paddingX * 2));

const boxX = (ctx.canvas.width / 2) - (boxW / 2);
const boxY = 20;

ctx.fillStyle = "rgba(255,255,255,0.10)";
roundRectPath(ctx, boxX, boxY, boxW, boxH, 10);
ctx.fill();

// Draw label text
ctx.fillStyle = "#f2f2f2";
ctx.fillText(statusText, ctx.canvas.width/2, boxY + boxH/2);


    const r = 140;
    const cy = 175;
    const margin = 36;
    const leftCx = 12 + (r + 18) + margin;
    const rightCx = ctx.canvas.width - 12 - (r + 18) - margin;

    const tachVal = rpm / 1000;
    drawClusterGauge(ctx, leftCx, cy, r,
      tachVal, 0, 8, 1, 0.2,
      {
        title: "TACHOMETER",
        unitLabel: "",
        showX1000: true,
        redStartFrac: 0.79,
        digitalText: `${rpm.toFixed(0)} RPM`,
        numberFormatter: (u) => `${u}`,
        needleColor: "#ff4a4a"
      }
    );

    const sp = mph(v);
    drawClusterGauge(ctx, rightCx, cy, r,
      sp, 0, 120, 20, 5,
      {
        title: "SPEEDOMETER",
        unitLabel: "mph",
        showX1000: false,
        redStartFrac: 0.92,
        digitalText: `${sp.toFixed(1)} mph`,
        numberFormatter: (u) => `${u}`,
        needleColor: "#ff4a4a"
      }
    );
  }

  function drawControlsPanel(){
    const ctx = controlsCtx;
    ctx.clearRect(0,0,ctx.canvas.width,ctx.canvas.height);

    ctx.fillStyle = "#0f0f0f";
    roundRectPath(ctx, 10, 12, ctx.canvas.width - 20, ctx.canvas.height - 24, 18);
    ctx.fill();

    drawGearLadder(ctx, 20, 16, 200, 262, gear);

    const py = 280;
    const pw = 62;
    const ph = 96;
    const gap = 10;
    const startX = 18;
    drawPedal(ctx, startX + 0*(pw+gap), py, pw, ph, "CLUTCH", clamp(clutch,0,1));
    drawPedal(ctx, startX + 1*(pw+gap), py, pw, ph, "BRAKE", clamp(brake,0,1));
    drawPedal(ctx, startX + 2*(pw+gap), py, pw, ph, "GAS", clamp(throttleEff,0,1));
  }

  const pt = document.getElementById('plotTime').getContext('2d');
  const ps = document.getElementById('plotSpeed').getContext('2d');

  function drawAxisPlot(ctx, series, marks, xlabel, ylabel, xMin, xMax, yMin, yMax, xMajor, xMinorDivs, yMajor, yMinorDivs){
    const W = ctx.canvas.width, H = ctx.canvas.height;
    ctx.clearRect(0,0,W,H);

    const L = 90, R = 18, T = 16, B = 64;
    const w = W - L - R;
    const h = H - T - B;

    ctx.fillStyle = "#fff";
    ctx.fillRect(0,0,W,H);

    function X(x){ return L + (x - xMin) * w / (xMax - xMin); }
    function Y(y){ return T + h - (y - yMin) * h / (yMax - yMin); }

    ctx.strokeStyle = "#cfcfcf";
    ctx.lineWidth = 1.5;
    ctx.strokeRect(L, T, w, h);

    ctx.strokeStyle = "#f0f0f0";
    ctx.lineWidth = 1;
    for (let xv = xMin; xv <= xMax + 1e-9; xv += xMajor / xMinorDivs){
      const xx = X(xv);
      ctx.beginPath(); ctx.moveTo(xx, T); ctx.lineTo(xx, T+h); ctx.stroke();
    }
    for (let yv = yMin; yv <= yMax + 1e-9; yv += yMajor / yMinorDivs){
      const yy = Y(yv);
      ctx.beginPath(); ctx.moveTo(L, yy); ctx.lineTo(L+w, yy); ctx.stroke();
    }

    ctx.strokeStyle = "#e0e0e0";
    ctx.lineWidth = 1.2;
    for (let xv = xMin; xv <= xMax + 1e-9; xv += xMajor){
      const xx = X(xv);
      ctx.beginPath(); ctx.moveTo(xx, T); ctx.lineTo(xx, T+h); ctx.stroke();
    }
    for (let yv = yMin; yv <= yMax + 1e-9; yv += yMajor){
      const yy = Y(yv);
      ctx.beginPath(); ctx.moveTo(L, yy); ctx.lineTo(L+w, yy); ctx.stroke();
    }

    ctx.fillStyle = "#111";
    ctx.font = "12px Arial";

    ctx.textAlign = "center";
    ctx.textBaseline = "top";
    for (let xv = xMin; xv <= xMax + 1e-9; xv += xMajor){
      const xx = X(xv);
      ctx.strokeStyle = "#999";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(xx, T+h);
      ctx.lineTo(xx, T+h+6);
      ctx.stroke();

      const lab = (Math.abs(xv) < 1e-9) ? "0" : String(Math.round(xv*100)/100);
      ctx.fillText(lab, xx, T+h+10);
    }

    ctx.textAlign = "right";
    ctx.textBaseline = "middle";
    for (let yv = yMin; yv <= yMax + 1e-9; yv += yMajor){
      const yy = Y(yv);
      ctx.strokeStyle = "#999";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(L-6, yy);
      ctx.lineTo(L, yy);
      ctx.stroke();
      ctx.fillText(String(Math.round(yv)), L-10, yy);
    }

    ctx.fillStyle = "#111";
    ctx.font = "14px Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "bottom";
    ctx.fillText(xlabel, L + w/2, H - 10);

    ctx.save();
    ctx.translate(26, T + h/2);
    ctx.rotate(-Math.PI/2);
    ctx.textAlign = "center";
    ctx.textBaseline = "top";
    ctx.fillText(ylabel, 0, 0);
    ctx.restore();

    ctx.strokeStyle = "#111";
    ctx.lineWidth = 2;
    ctx.beginPath();
    let started = false;
    for (const p of series){
      if (p.x < xMin || p.x > xMax) continue;
      const xx = X(p.x);
      const yy = Y(p.y);
      if (!started){ ctx.moveTo(xx,yy); started = true; }
      else ctx.lineTo(xx,yy);
    }
    ctx.stroke();

    ctx.fillStyle = "#111";
    ctx.font = "12px Arial";
    ctx.textAlign = "left";
    ctx.textBaseline = "alphabetic";

    const LABEL_X_OFFSET = 8;
    const LABEL_Y_OFFSET = -8;
    const LABEL_STEP_PX = 14;
    const LABEL_LINE_H = 13;
    const LABEL_PAD = 2;

    const placed = [];

    function rectsOverlap(a, b){
      return !(a.x + a.w < b.x || b.x + b.w < a.x || a.y + a.h < b.y || b.y + b.h < a.y);
    }

    const visibleMarks = marks
      .filter(m => m.x >= xMin && m.x <= xMax)
      .slice()
      .sort((a,b) => a.x - b.x);

    for (const m of visibleMarks){
      const xx = X(m.x);
      const yy = Y(m.y);

      ctx.beginPath();
      ctx.arc(xx, yy, 3, 0, Math.PI*2);
      ctx.fill();

      const lines = String(m.label).split("\n");
      const textW = Math.max(...lines.map(line => ctx.measureText(line).width));
      const textH = lines.length * LABEL_LINE_H;

      let tx = xx + LABEL_X_OFFSET;
      let ty = yy + LABEL_Y_OFFSET;

      const minX = L + 4;
      const maxX = L + w - 4 - textW;
      tx = clamp(tx, minX, maxX);

      function makeRect(tx0, ty0){
        return {
          x: tx0 - LABEL_PAD,
          y: (ty0 - (textH - LABEL_LINE_H)) - LABEL_LINE_H - LABEL_PAD,
          w: textW + 2*LABEL_PAD,
          h: textH + 2*LABEL_PAD
        };
      }

      let placedRect = null;

      for (let pass = 0; pass < 2 && !placedRect; pass++){
        for (let k = 0; k < 30; k++){
          const ddy = (pass === 0) ? -k * LABEL_STEP_PX : +k * LABEL_STEP_PX;
          const tyTry = ty + ddy;

          const r = makeRect(tx, tyTry);

          if (r.y < T + 4) continue;
          if (r.y + r.h > T + h - 4) continue;

          let collide = false;
          for (const p of placed){
            if (rectsOverlap(r, p)) { collide = true; break; }
          }
          if (!collide){
            placedRect = r;
            ty = tyTry;
            placed.push(r);
            break;
          }
        }
      }

      for (let i = 0; i < lines.length; i++){
        ctx.fillText(lines[i], tx, ty + i * LABEL_LINE_H);
      }
    }
  }

  function drawPlots(){
    const runDurationS = clamp(parseFloat(elRunTime.value) || 120, 5, 600);

    drawAxisPlot(pt, timeSeries, shiftMarksTime,
      "time (s)",
      "revolutions per minute (RPM)",
      0, runDurationS, 0, redline,
      Math.max(5, Math.round(runDurationS/12)), 5,
      1000, 5
    );

    drawAxisPlot(ps, speedSeries, shiftMarksSpeed,
      "vehicle speed (mph)",
      "revolutions per minute (RPM)",
      0, speedMaxMph, 0, redline,
      10, 5, 1000, 5
    );
  }

  let last = performance.now();
  function loop(now){
    requestAnimationFrame(loop);
    const dtReal = clamp((now - last) / 1000, 0, 0.05);
    last = now;

    if (elLoop && elLoop.checked && (now - lastInteractionMs) > getInactivityRestartMs()) {
      reset();
      running = true;
      lastInteractionMs = now;
    }

    if (running) update(dtReal);

    drawGaugesPanel();
    drawControlsPanel();
    drawPlots();
  }

  function reset(){
    updateRatiosFromUI();

    t = 0; v = 0; rpm = 0; gear = 1;
    shifting = false; shiftTimer = 0; shiftTotal = 0;
    lastShiftEndAt = -1;

    clutch = 1.0;
    brake = 0.2;
    throttleEff = 0;

    timeSeries.length = 0;
    speedSeries.length = 0;
    shiftMarksTime.length = 0;
    shiftMarksSpeed.length = 0;

    shiftMarksTime.push({ x: 0, y: 0, label: "  idle, 1st gear" });
    shiftMarksSpeed.push({ x: 0, y: 0, label: "  idle, 1st gear" });

    running = false;
  }

  function refreshDragLabel(){
    dragCoef = parseFloat(elDragCoef.value);
    if (!Number.isFinite(dragCoef)) dragCoef = 0.32;
    dragCoefLabel.textContent = `Drag coefficient: ${dragCoef.toFixed(2)} (drag = coef * v²)`;
  }

  function refreshLabels(){
    const driverThrottle = parseFloat(elThrottleIn.value);
    const upshiftGlobal = parseFloat(elUpshift.value);
    const downshiftRPM = parseFloat(elDownshift.value);

    let upshiftRPM = getUpshiftRpmForGear(gear, upshiftGlobal);
    upshiftRPM = Math.max(upshiftRPM, downshiftRPM + MIN_UPSHIFT_ABOVE_DOWNSHIFT);

    throttleLabel.textContent = `Driver throttle: ${(driverThrottle*100).toFixed(0)}%`;
    upshiftLabel.textContent = `Upshift: ${upshiftRPM.toFixed(0)} rpm (gear ${gear})`;
    downshiftLabel.textContent = `Downshift: ${downshiftRPM.toFixed(0)} rpm`;
    shiftTimeLabel.textContent = `Shift time: ${parseFloat(elShiftTime.value).toFixed(2)} s`;
  }

  elThrottleIn.addEventListener('input', refreshLabels);
  elUpshift.addEventListener('input', refreshLabels);
  elDownshift.addEventListener('input', refreshLabels);
  elShiftTime.addEventListener('input', refreshLabels);
  elDragCoef.addEventListener('input', refreshDragLabel);

  if (elIdleSeconds){
    elIdleSeconds.addEventListener('input', () => markInteraction("controls"));
    elIdleSeconds.addEventListener('change', () => markInteraction("controls"));
  }

  refreshLabels();
  refreshDragLabel();

  reset();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
